# rabbitmq学习
### RabbitMq原理图
![image-2024052101](/img/原理.png) <br/>
黄色的圈圈就是我们的消息推送服务,将消息推送到中间方框里面也就是 rabbitMq的服务器,<br/>
然后经过服务器里面的交换机、队列等各种关系将数据处理入列后，
最终右边的蓝色圈圈消费者获取对应监听的消息。

### RabbitMq工作流程图
![image-2024052102](/img/工作流程.png) <br/>
组成部分说明：
Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue <br/>
Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑.<br/>
Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费者. <br/>
Producer：消息生产者，即生产方客户端，生产方客户端将消息发送. <br/>
Consumer：消息消费者，即消费方客户端，接收MQ转发的消息.

生产者发送消息流程：
1. 生产者和Broker建立TCP连接。
2. 生产者和Broker建立通道。
3. 生产者通过通道消息发送给Broker，由Exchange将消息进行转发。
4. Exchange将消息转发到指定的Queue（队列）

消费者接收消息流程：
1. 消费者和Broker建立TCP连接
2. 消费者和Broker建立通道
3. 消费者监听指定的Queue（队列）
4. 当有消息到达Queue时Broker默认将消息推送给消费者。
5. 消费者接收到消息。
6. ack回复

### RabbitMQ 交换机类型
Exchange(交换机)只负责转发消息,不具备存储消息的能力,因此如果没有任何队列与Exchange绑定,或者没有符合路由规则的队列,那么消息会丢失！<br/>
交换机接收消息,而如何处理消息取决于交换机的类型。
#### Direct exchange(直连交换机)
直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的，步骤如下：
1. 将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）
2. 当一个携带着路由值为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。

#### Fanout exchange（扇型交换机）
扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列。不同于直连交换机，<br/>
路由键在此类型上不启任务作用。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，
交换机会将消息的发送给这所有的N个队列

#### Topic exchange（主题交换机）
主题交换机（topic exchanges）中，队列通过使用通配符路由key绑定到交换机上,然后,交换机根据消息里的路由值,将消息路由给一个或多个绑定队列。<br/>

扇型交换机和主题交换机异同：
对于扇型交换机路由键是没有意义的，只要有消息，它都发送到它绑定的所有队列上
对于主题交换机，路由规则由路由键决定，只有满足路由键的规则，消息才可以路由到对应的队列上

介绍一下规则
1. .(逗号) 分割多个路由key, key1.key2.key3 
2. \*(星号) 用来表示一个单词(必须出现的), \*.key2.\* 
3. #(井号) 用来表示匹配任意数量(零个或多个)单词 通配的绑定键是跟队列进行绑定的 <br/>
当一个队列的绑定键为 #（井号） 的时候,这个队列将会无视消息的路由键,接收所有的消息。 <br/>
当*(星号) 和#(井号) 这两个特殊字符都未在绑定键中出现的时候,此时主题交换机就拥有的直连交换机的行为。<br/>
所以主题交换机也就实现了扇形交换机的功能，和直连交换机的功能。

### RabbitMQ 经典用法(工作模式)
![image-2024052103](/img/工作模式.png) <br/>
生产者将消息直接发送到队列,有一个消费者监听监听该队列就是简单模式,有多个消费者监听就是工作队列模式 <br/>
生产者将消息直接发送到交换机和有队列使用路由key绑定交换机,就是发布订阅模式。<br/>
路由模式就是在发布订阅模式上使用直连型交换机。<br/>
主题模式就是在发布订阅模式上使用主题交换机。<br/>
发送端消息确认模式是在生产者自定义消息发送成功或失败的回调处理。<br/>

### 消息可靠性投递
1. 故障情况1：消息没有发送到消息队列 <br/>
 解决思路A：在生产者端进行确认,具体操作中我们会分别针对交换机和队列来确认，
 如果没有成功发送到消息队列服务器上,那就可以尝试重新发送 <br/>
 解决思路B：为目标交换机指定备份交换机，当目标交换机投递失败时，把消息投递至
备份交换机。<br/>
![image-2024052104](/img/备份交换机原理.png) <br/>
2. 故障情况2：消息队列服务器宕机导致内存中消息丢失 <br/>
  解决思路：消息持久化到硬盘上,哪怕服务器重启也不会导致消息丢失
3. 故障情况3：消费端宕机或抛异常导致消息没有成功被消费 <br/>
 开启消费端手动确认模式,自动模式(默认)下消费端收到信息后,消息队列自动删除该消息,如果消费端收到消息在进行业务处理时中途发错误后业务代码回滚,导致该信息没有被成功消费。<br/>
 消费端消费消息成功,给服务器返回ACK信息,然后消息队列删除该消息。 <br/>
 消费端消费消息失败,给服务器端返回NACK信息,同时把消息恢复为待消费的状态。
这样就可以再次取回消息,重试一次(当然,这就需要消费端接口支持幂等性)

### 消息超时
给消息设定一个过期时间，超过这个时间没有被取走的消息就会被删除。<br/>
可以从两个层面来给消息设定过期时间：
1. 队列层面：在队列层面设定消息的过期时间，并不是队列的过期时间。意思是这
个队列中的消息全部使用同一个过期时间。
2. 消息本身：给具体的某个消息设定过期时间

### 死信
概念：当一个消息无法被消费，它就变成了死信。

###### 死信产生的原因大致有下面三种：
 - 拒绝：消费者拒接消息，basicNack()/basicReject()，并且不把消息重新放入原目标队
 列，requeue=false
 - 溢出：队列中消息数量到达限制。比如队列最大只能存储10条消息，且现在已经存储
 了10条，此时如果再发送一条消息进来，根据先进先出原则，队列中最早的消息会变
 成死信
 - 超时：消息到达超时时间未被消费 

###### 死信的处理方式大致有下面三种：
 - 丢弃：对不重要的消息直接丢弃，不做处理
 - 入库：把死信写入数据库，日后处理
 - 监听：消息变成死信后进入死信队列，我们专门设置消费端监听死信队列，做后续处
理（通常采用）





